<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDF → JSON Extractor (Abstract Only)</title>
  <style>
    body { font-family: system-ui; max-width: 980px; margin: 40px auto; padding: 0 16px; }
    textarea, input { width: 100%; }
    textarea { min-height: 110px; }
    pre { background: #f6f8fa; padding: 12px; border-radius: 10px; overflow:auto; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items: center; }
    button { padding: 10px 14px; cursor:pointer; }
    input[type="file"] { padding: 8px; }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 14px; margin-top: 12px; }
    small { color: #555; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background:#eef2ff; font-size:12px; }
    .warn { background:#fff7ed; border:1px solid #fed7aa; padding:10px; border-radius:10px; }
  </style>
</head>
<body>
  <h1>PDF → JSON Extractor (Abstract Only)</h1>
  <p><small class="pill">Frontend: GitHub Pages</small> <small class="pill">Backend: Vercel API</small></p>

  <div class="card">
    <h3>1) Choose a PDF</h3>
    <div class="row">
      <input id="pdf" type="file" accept="application/pdf" />
      <button id="loadBtn">Load PDF Text</button>
    </div>
    <p><small id="status">No PDF loaded.</small></p>
    <details>
      <summary><small>Preview (Abstract if detected, else first ~2000 chars)</small></summary>
      <pre id="preview"></pre>
    </details>
    <div id="abstractNote" class="warn" style="display:none;">
      <small><b>Note:</b> Abstract heading wasn’t detected reliably, so the app will fall back to using the full text. If you want, share a snippet of the extracted text around the abstract heading and we can tune the detector.</small>
    </div>
  </div>

  <div class="card">
    <h3>2) Extraction instruction</h3>
    <textarea id="query">Extract mentions of materials and the properties they have which are mentioned in the abstract.</textarea>

    <h3 style="margin-top:14px;">3) JSON Schema</h3>
    <textarea id="schema">
{
  "type": "object",
  "properties": {
    "items": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "material": { "type": "string" },
          "properties": { "type": "array", "items": { "type": "string" } },
          "evidence": { "type": "array", "items": { "type": "string" } }
        },
        "required": ["material", "properties"]
      }
    }
  },
  "required": ["items"]
}
    </textarea>

    <div class="row" style="margin-top:12px;">
      <button id="runBtn">Run Extraction (OpenAI)</button>
      <button id="downloadBtn">Download JSON</button>
    </div>
  </div>

  <div class="card">
    <h3>Result (JSON)</h3>
    <pre id="out">{}</pre>
  </div>

  <script type="module">
    const API_BASE = "https://wajahathssn-github-io.vercel.app/api";

    let pdfText = "";
    let abstractText = "";
    const statusEl = document.getElementById("status");
    const previewEl = document.getElementById("preview");
    const outEl = document.getElementById("out");
    const abstractNoteEl = document.getElementById("abstractNote");

    async function pdfToText(file) {
      const arrayBuffer = await file.arrayBuffer();
      const pdfjsLib = await import("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs");
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs";

      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

      let text = "";
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const pageText = content.items.map(it => it.str).join(" ");
        text += `\n\n[Page ${i}]\n${pageText}`;
      }
      return text.trim();
    }

    // Attempts to extract the abstract section.
    // Falls back to null if not confidently detected.
    function extractAbstractFromText(fullText) {
      const t = (fullText || "").replace(/\r/g, "");

      // Try common "Abstract" heading patterns
      const startMatch =
        t.match(/\n\s*(Abstract|ABSTRACT)\s*[:\n]\s*/);

      if (!startMatch) return null;

      const startIdx = startMatch.index + startMatch[0].length;
      const rest = t.slice(startIdx);

      // Try common next headings
      const endMatch = rest.match(
        /\n\s*(Keywords?|KEYWORDS?|Introduction|INTRODUCTION|1\.?\s*Introduction|Results|RESULTS|Methods|METHODS|Background|BACKGROUND)\s*[:\n]\s*/
      );

      const endIdx = endMatch ? startIdx + endMatch.index : Math.min(t.length, startIdx + 7000);

      const abstract = t.slice(startIdx, endIdx).trim();

      // Guard against bad detection
      if (abstract.length < 150) return null;

      return abstract;
    }

    document.getElementById("loadBtn").onclick = async () => {
      try {
        abstractNoteEl.style.display = "none";
        outEl.textContent = "{}";
        previewEl.textContent = "";

        const f = document.getElementById("pdf").files[0];
        if (!f) return alert("Choose a PDF first.");

        statusEl.textContent = "Extracting text from PDF in the browser...";
        pdfText = await pdfToText(f);

        abstractText = extractAbstractFromText(pdfText) || "";

        const toPreview = abstractText || pdfText;
        previewEl.textContent =
          toPreview.slice(0, 2000) + (toPreview.length > 2000 ? "\n\n...[truncated]" : "");

        if (abstractText) {
          statusEl.textContent = `Abstract detected (${abstractText.length.toLocaleString()} chars). Ready to run extraction.`;
        } else {
          statusEl.textContent = `Abstract not detected reliably. Loaded full text (${pdfText.length.toLocaleString()} chars).`;
          abstractNoteEl.style.display = "block";
        }
      } catch (e) {
        console.error(e);
        statusEl.textContent = "Failed to extract PDF text.";
        alert("Failed to extract PDF text. Try a different PDF or smaller file.");
      }
    };

    document.getElementById("runBtn").onclick = async () => {
      try {
        if (!pdfText) return alert("Load PDF text first (click 'Load PDF Text').");

        const query = document.getElementById("query").value.trim();
        if (!query) return alert("Enter an extraction instruction.");

        let schema;
        try {
          schema = JSON.parse(document.getElementById("schema").value);
        } catch {
          return alert("Schema is not valid JSON.");
        }

        outEl.textContent = "Calling backend...";

        // Abstract-only if detected; otherwise fallback to full text.
        const textToUse = abstractText || pdfText;
        const prompt = `DOCUMENT TEXT (ABSTRACT ONLY):\n${textToUse}\n\nTASK:\n${query}`;

        const r = await fetch(`${API_BASE}/extract_json`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt, schema })
        });

        const data = await r.json();

        if (!r.ok) {
          outEl.textContent = JSON.stringify(data, null, 2);
          return;
        }

        outEl.textContent = JSON.stringify(data.result ?? data, null, 2);
      } catch (e) {
        console.error(e);
        outEl.textContent = JSON.stringify({ error: String(e?.message || e) }, null, 2);
      }
    };

    document.getElementById("downloadBtn").onclick = () => {
      const text = outEl.textContent || "{}";
      const blob = new Blob([text], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "extraction-result.json";
      a.click();
      URL.revokeObjectURL(a.href);
    };
  </script>
</body>
</html>
